# golang知识点汇总

## go的调度

   调度可以理解为一个指挥员，指导程序按照一定的规则去获取资源，然后执行里面的任务指令。

   常见的调度策略有两种:   
   
      1. 协作式调度：会让程序顺利完成自己的任务，再把资源腾出来给其他程序使用。 

         优点： 有利于程序专注完成自己的任务，避免频繁切换
         缺点： 可能会其他程序等待调度时间过长，造成饿死，得不到执行

      2. 抢占式调度：让程序按一定的时间去占有这些资源，时间到了，就被迫让出现有资源，给其他程序轮流使用

         优点： 有利于程序在资源利用上雨露均沾
         缺点： 但是在频繁的切换过程中，将会使原本10ms能完成的任务，不得不多几ms完成

    golang采用了基于协作的抢占式调度，之所以是协作的，是因为go的调度时机是用户自己设置的，而这里的用户指的是golang的
    运行时runtime。

  触发调度的事件：

       1. 使用关键字go

       2. 垃圾回收

       3. 系统调用（sys.call），如访问磁盘

       4. 同步阻塞调用，如使用mutx，channel

  如果上面什么事件都没发生，则会有sysmon 来监控goroutine的运行情况，对长时间运行的goroutine进行标记。
  一旦goroutine 被标记了，那么它就会下次发生函数调用时，将自己挂起，再触发调度。
  
  此外runtime模块负责了go的很多东西，比入调度，垃圾回收，内存管理等等，涵盖了go的基础引擎了，更重要的是runtime是运行在
  用户态上的，相当于go的调度是在用户态这一层进行的。 这样每当go有调度产生时，就不会伴随用户态和内核态的切换，降低了
  并发时内核态与用户态的切换成本。
