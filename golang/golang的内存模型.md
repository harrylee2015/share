# golang的内存模型

## 前言

go语言内存模型保证同一个变量在不同goroutine被读写到正确的值。一种情况是，变量在一个goroutine中被写入以后，另一个goroutine能够观测到最新写入的结果。我们称之为顺序一致性模型。


程序中的数据同时被多个goroutine访问（包括读和写）时，这些并发的访问必须以一定的顺序进行。
 
为了将访问序列化，一种方法是采用channel，一种是使用早期的同步控制方式，比如sync、sync/atomic包。

## Part 1：Happens Before（发生在...之前）

为了精确表述读取和写入的顺序，我们定义了happens before（在…之前发生），它是一种go程序内存操作的执行偏序。

HappensBefore：如果事件 e1发生在事件e2之前，那么我们声称事件e2发生在事件e1之后。
 
并发执行：如果事件e1没有发生在事件e2之前，且事件e2没有发生在事件e1之前，那么我们声称事件e1和事件e2并发执行。

在单一goroutine中，happens before偏序就是程序表现出的顺序。

当多个goroutine使用变量 V 时，这些goroutine必须采用同步事件去建立happens before条件，以保证读操作能够观察到需要的写操作。


## Part 2：Synchronization（同步）

2.1 初始化（Initialization）
程序初始化时，只会启动一个goroutine，但是这个goroutine可能会创建其它 goroutine，新创建的goroutine并发执行。
 
如果 package p imports package q，那么q的init函数全部执行结束后，p中的init函数才会开始执行。
 
所有init函数全部执行结束之后，main.main函数才开始执行。

2.2 Goroutine的创建

使用“go”修饰一个语句时，会创建一个新的goroutine。go 修饰的语句执行以后，启动的goroutine才会开始执行。

2.3 Goroutine的销毁

goroutine的退出与程序中的任何事件不存在happens-before关系。

**如果一个goroutine的结果需要被另一个goroutine观察到，必须采用一些同步机制（锁、channel）建立相对顺序。**


## Go语言的内存分配策略


Go语言的内存分配主要基于tcmalloc（Thread-Caching Malloc）算法，这是一种高效的内存分配器，旨在减少多线程程序中的锁竞争，并提高内存分配和释放的效率。

内存分配的基本流程：

内存划分：
Go的运行时系统将内存划分为多个区域，包括堆（heap）、栈（stack）和全局变量区等。
堆用于动态分配内存，是内存分配的主要区域。
内存分配器：
Go使用基于tcmalloc的内存分配器，该分配器将内存划分为多个大小不同的块（block）。
每个块都有对应的空闲列表（free list），用于管理未使用的内存块。
分配策略：
小对象分配：对于小对象（通常小于32KB），分配器会从对应的空闲列表中直接分配一个内存块。
大对象分配：对于大对象，分配器会直接从堆中分配连续的内存空间。
缓存机制：
tcmalloc在每个线程中都维护了一个本地缓存（thread cache），用于存储最近释放的小对象。
当线程需要分配内存时，首先检查本地缓存，如果找到合适的内存块，则直接分配；否则，从中心的空闲列表中分配。
内存释放：
当对象不再使用时，内存会被释放并返回到对应的空闲列表。
对于小对象，内存会被放入线程的本地缓存；对于大对象，内存会被直接返回到堆中。
内存分配的特点：

高效性：通过本地缓存和空闲列表，减少了锁竞争和内存碎片，提高了内存分配和释放的效率。
可扩展性：支持多线程环境，能够有效地处理大量并发内存分配请求。
内存碎片管理：通过合理的内存划分和分配策略，减少了内存碎片的产生。
总结：

Go语言的内存分配策略基于tcmalloc算法，通过高效的内存划分、分配策略和缓存机制，实现了快速、可扩展的内存管理。这种策略有助于提高Go程序的性能和稳定性，特别是在多线程和高并发场景下。
