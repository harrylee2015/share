## 缓存模式

### 缓存模式-数据一致性问题

当数据发生更新时：

1.先更新db中数据，后更新缓存中数据

2.更新缓存中数据时，因为某种原因可能会产生happen before问题，并发关系导致先后问题，这时候可以通过key的版本控制来解决，上缓存中的key版本号和之前一致时才更新。



### 缓存模式-多级缓存

微服务拆分细粒度原子业务下的整合服务（聚合服务，用于提供粗粒度的接口，以及二级缓存加速，减少扇出的rpc网络请求，减少延迟。最重要是保证多级缓存的一致性：

* 清理的优先级是有要求的，优先清理下游再清理上游

* 下游的缓存expire(过期时间)要大于上游，以便穿透回源


### 缓存模式-热点缓存

对于热点缓存key，按照如下思路解决：

1.小表广播，从remotecache提升为localcache， app定时更新，甚至可以让运营平台支持广播刷新localcache.

2.主动监控防热点，比如直播房间号高在线情况下直接外挂服务主动防御。

3.基础库框架支持热点发现，自动短时的short-live cache,会自动标记热点

4.多cluster支持
   * 多key设计：使用多副本，减少节点热点的问题。
  
   * 使用多副本 ms_1,ms_2,ms_3  每个节点保持一份数据，将请求打散到多个节点上面，避免单节   点热点问题。用空间换时间


### 缓存模式- 穿透缓存

1.singlefly（单飞）

对关键字进行一致性hash，使其某一个维度的key一定命中某个节点，然后再节点内使用互斥锁，保证归并会员，但是对于批量查询无解。

2.分布式锁

设置一个lock key，有且只有一个人成功，并且返回，交由这个人执行回源操作，其他候选者轮询cache这个lock key，如果不存在去读数据缓存，
命中就返回，miss就继续抢锁。


3.队列

如果cache miss，交由队列聚合一个key,来load数据回写缓存，对于misss当前请求可以使用singlefly保证回源，如评论架构实现。
适合回源加载数据重的任务，比如评论miss只返回第一页，但是需要构建完正评论数据索引。

4.lease(租约）

通过加入lease机制，可以很好避免这两个问题，lease是64-bit的token，与客户端请求的key绑定，对于过时设置，再写入时验证lease,
可以解决这个问题；对于大批量访问时，每个key 10s分配一次，当client在没有会哦去到lease时，可以稍微等一下再访问cache,
这时往往cache中已经有数据。
