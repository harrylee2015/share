# 高并发处理

## 思想 

   筛选有效流量
   
   异步处理数据


## 优化思路

   * 系统特征： 高并发，大流量
   
   * 优化方向： 提高网站性能，保护数据库
   
   * 具体措施： 静态化，分布式，缓存，消息队列

## [什么是cookie，什么是session?](https://juejin.cn/post/7133758754818326564)
  
   * Cookie: 采用的是在客户端保存状态和数据的方案 （客户浏览器上），单个Cookie保存的数据不能超过4K
       
        ps: 为了防止客服端伪造登录ID，或者token令牌，这里一般会用到AES等对称加密技术对真实数据进行加密，然后在服务端进行解密
           
   * Session： 采用在服务器端保存状态和数据的方案 （服务器上），当访问增多，会比较占用大量资源


## 限流

### 计数器算法

 在一定时间内，对处理的请求数进行计数，每次到达时间临界点则计数器清零。在一定时间间隔内，若计数器数字超限，则进行限流。
 （缺点,该算法的问题是，在两端临界点附加可能出现两倍的流速。)

### 滑动窗口算法

  基于计数器算法那，采用微积分的思想，把时间间隔分片。例如服务限流每秒处理100个请求，把1秒分为10个窗口。每100毫秒移动一次，内存中保留每次的请求次数。每次移动判断一下总次数是否超限。

 当滑动窗口的格子划分的越多，滑动窗口的滚动就越平滑，限流的统计就会越精确。
 滑动窗口算法可以有效规避计数器算法中时间临界点问题。但实现起来相对比较复杂。

  Hystrix的限流基于滑动窗口算法实现。

    
### 令牌桶算法

  系统已一个恒定的速率往桶放入令牌。若有请求需要处理，则从令牌桶里获取令牌，当桶里没有令牌，则拒绝服务。

  令牌桶算法并不能实际的控制速率。比如，10秒往桶里放入10000个令牌桶，即10秒内只能处理10000个请求，那么qps就是100。但这种模型可以出现1秒内把10000个令牌全部消费完，即qps为10000。所以令牌桶算法实际是限制的平均流速。具体控制的粒度以放令牌的间隔和每次的量来决定。若想要把流速控制的更加稳定，就要缩短间隔时间。

  golang中的RateLimter就是利用的令牌桶原理。

### 漏桶算法
  
  水滴先进入漏桶，漏桶以一定速度向外出水。当水流入速度过大，桶会直接溢出。

 即Request进入一个固定容量的Queue，若Queue满，则拒绝新的Request，可以阻塞，也可以抛异常。这种模型其实非常类似MQ的思想，利用漏桶削峰填谷，使得Queue的下游具有一个稳定流量。
