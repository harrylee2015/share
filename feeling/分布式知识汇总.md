# 分布式知识汇总

## 分布式锁

分布式锁的特点

**原子性（互斥性）：**  互斥是锁的基本特性，同一时刻只能有一个线程持有锁，执行临界操作；

**超时释放：** 超时释放是锁的另外一个必备特性，通过超时释放，防止不必要的线程等待和资源浪费；

**可重入性：**  在分布式环境中，同一个节点上的同一对象（如线程、类）可以重复、递归调用该锁而不发生死锁；

**可阻塞：** 在没有获得锁之前，只能阻塞等待直至获得锁；

**高性能和高可用：** 加锁和解锁的开销要尽可能的小，同时也要保证高可用，防止分布式锁失效；

[分布式锁实现的几种方式](https://segmentfault.com/a/1190000017241446?utm_source=tag-newest)


## 如何使用redis快速实现分布式锁

   * 使用setnx实现分布式锁
   
     redis支持setnx执行，直在key不存在的情况下，将key的值设置为value,若key已经存在，则setnx命令不做任何动作。使用setnx实现分布式锁的方案，
     获取锁的方法很简单，只要以该锁为 key，设置一个随机的值即可。如果 setnx 返回 1，则说明该进程获得锁；如果 setnx 返回 0，
     则说明其他进程已经获得了锁，进程不能进入临界区；如果需要阻塞当前进程，可以在一个循环中不断尝试 setnx 操作。
     
      ```
      if(setnx(key,value)==1){
       try{
        //业务处理
       }finally{
       //释放锁
        del(key)
       }
      }
      ```


      释放锁时只要删除对应的 key 就可以，为了防止系统业务进程出现异常导致锁无法释放，使用 Java 中的 try-catch-finally 来完成锁的释放。
      对比一下上面说的分布式锁特性，使用这种方式实现分布式锁的问题很明显：不支持超时释放锁，如果进程在加锁后宕机，则会导致锁无法删除，其他进程无法获得锁。
      
       
   * 使用 setnx 和 expire 实现
    
     在分布式锁的实现中，依赖业务线程进行锁的释放，如果进程宕机，那么就会出现死锁。Redis 在设置一个 key 时，支持设置过期时间，利用这一点，可以在缓存中实现锁的超时释放，解决死锁问题。

     在使用 setnx 获取锁之后，通过 expire 给锁加一个过期时间，利用 Redis 的缓存失效策略，进行锁的超时清除。

      伪代码如下：

        ```
         if(setnx(key,value)==1){
            expire(key,expireTime)
            try{
             //业务处理
             }finally{
               //释放锁
               del(key)
             }
           }
        ```

      通过设置过期时间，避免了占锁到释放锁的过程发生异常而导致锁无法释放的问题，但是在 Redis 中，setnx 和 expire 这两条命令不具备原子性。如果一个线程在执行完 setnx 之后突然崩溃，导致锁没有设置过期时间，那么这个锁就会一直存在，无法被其他线程获取。
      
      
   * 使用set扩展命令实现
   
      为了解决上面问题，在redis 2.8版本中，扩展了set命令，支持set和 expire指令组合原子操作，解决了加锁过程中失败的问题。
      
      set 扩展参数的语法如下：
        
       ```
        redis> SET key value expireTime nx
       ```

      nx 表示仅在键不存在时设置，这样可以在同一时间内完成设置值和设置过期时间这两个操作，防止设置过期时间异常导致的死锁。那么这种方式还存在问题吗？

      使用 setex 方式看起来解决了锁超时的问题，但在实际业务中，**如果对超时时间设置不合理，存在这样一种可能：在加锁和释放锁之间的业务逻辑执行的太长，以至于超出了锁的超时限制，缓存将对应 key 删除，其他线程可以获取锁，出现对加锁资源的并发操作。**

      我们来模拟下这种情况：

        * 客户端 A 获取锁的时候设置了 key 的过期时间为 2 秒，客户端 A 在获取到锁之后，业务逻辑方法执行了 3 秒；
        * 客户端 A 获取的锁被 Redis 过期机制自动释放，客户端 B 请求锁成功，出现并发执行；
        * 客户端 A 执行完业务逻辑后，释放锁，删除对应的 key；
        * 对应锁已经被客户端 B 获取到了，客户端A释放的锁实际是客户端B持有的锁。
        
        可以看到，第一个线程的逻辑还没执行完，第二个线程也成功获得了锁，加锁的代码或者资源并没有得到严格的串行操作，同时由于叠加了删除和释放锁操作，导致了加锁的混乱。

        如何避免这个问题呢？**首先，基于 Redis 的分布式锁一般是用于耗时比较短的瞬时性任务，业务上超时的可能性较小；其次，在获取锁时，可以设置 value 为一个随机数，在释放锁时进行读取和对比，确保释放的是当前线程持有的锁，一般是通过 Redis 结合 Lua 脚本的方案实现；最后，需要添加完备的日志，记录上下游数据链路，当出现超时，则需要检查对应的问题数据，并且进行人工修复。**
        
## 分布式锁的高可用        
        
   上面分布式锁的实现方案中，都是针对单节点 Redis 而言的，在生产环境中，为了保证高可用，避免单点故障，通常会使用 Redis 集群。

   * 集群下分布式锁存在哪些问题
   
     集群环境下，Redis 通过主从复制来实现数据同步，Redis 的主从复制（Replication）是异步的，所以单节点下可用的方案在集群的环境中可能会出现问题，在故障转移（Failover） 过程中丧失锁的安全性。

     **由于 Redis 集群数据同步是异步的，假设 Master 节点获取到锁后在未完成数据同步的情况下，发生节点崩溃，此时在其他节点依然可以获取到锁，出现多个客户端同时获取到锁的情况。**

     我们模拟下这个场景，按照下面的顺序执行：

        * 客户端 A 从 Master 节点获取锁；
        * Master 节点宕机，主从复制过程中，对应锁的 key 还没有同步到 Slave 节点上；
        * Slave 升级为 Master 节点，于是集群丢失了锁数据；
        * 其他客户端请求新的 Master 节点，获取到了对应同一个资源的锁；
        * 出现多个客户端同时持有同一个资源的锁，不满足锁的互斥性。
        
     可以看到，单实例场景和集群环境实现分布式锁是不同的，关于集群下如何实现分布式锁，Redis 的作者 Antirez（Salvatore Sanfilippo）提出了 Redlock 算法，我们一起看一下。

   * Redlock 算法的流程
   
      Redlock 算法是在单 Redis 节点基础上引入的高可用模式，Redlock 基于 N 个完全独立的 Redis 节点，一般是大于 3 的奇数个（通常情况下 N 可以设置为 5），可以基本保证集群内各个节点不会同时宕机。

      假设当前集群有 5 个节点，运行 Redlock 算法的客户端依次执行下面各个步骤，来完成获取锁的操作：

        * 客户端记录当前系统时间，以毫秒为单位；
      
        * 依次尝试从 5 个 Redis 实例中，使用相同的 key 获取锁，当向 Redis 请求获取锁时，客户端应该设置一个网络连接和响应超时时间，超时时间应该小于锁的失效时间，避免因为网络故障出现的问题；
        * 客户端使用当前时间减去开始获取锁时间就得到了获取锁使用的时间，当且仅当从半数以上的 Redis 节点获取到锁，并且当使用的时间小于锁失效时间时，锁才算获取成功；
        * 如果获取到了锁，key 的真正有效时间等于有效时间减去获取锁所使用的时间，减少超时的几率；
        * 如果获取锁失败，客户端应该在所有的 Redis 实例上进行解锁，即使是上一步操作请求失败的节点，防止因为服务端响应消息丢失，但是实际数据添加成功导致的不一致。
        
   在redis官方推荐的java客户端redisson中内置了对redlock的实现，同样golang客户端中也有对分布式锁的实现。[golang实现的redis客户端](https://github.com/go-redis/redis)
